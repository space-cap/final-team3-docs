# 04. 보안 및 인증

## 보안 개요

이 시스템은 JWT 기반의 무상태(stateless) 인증 방식을 채택하여 확장성과 성능을 고려한 보안 아키텍처를 구현했습니다.

### 주요 보안 특징
- **JWT 기반 인증**: Access Token + Refresh Token 조합
- **BCrypt 패스워드 암호화**: 솔트 자동 생성, 강력한 해싱
- **Spring Security**: 인증/인가 중앙 관리
- **계정 잠금 시스템**: 무차별 대입 공격 방어
- **CORS 정책**: 개발/운영 환경별 설정

## JWT 토큰 시스템

### 토큰 구조

#### 1. Access Token
**유효기간**: 30분 (1,800초)
**용도**: API 호출 시 인증
**페이로드**:
```json
{
  "sub": "1",           // 사용자 ID
  "email": "user@example.com",
  "roles": ["USER"],
  "iat": 1640995200,    // 발행 시간
  "exp": 1640997000     // 만료 시간
}
```

#### 2. Refresh Token  
**유효기간**: 14일 (1,209,600초)
**용도**: Access Token 갱신
**페이로드**:
```json
{
  "sub": "1",           // 사용자 ID  
  "iat": 1640995200,    // 발행 시간
  "exp": 1642204800     // 만료 시간
}
```

### 토큰 생성 및 검증

#### JwtTokenProvider 핵심 기능
```java
// 토큰 생성
public String createAccessToken(Long userId, String email, List<String> roles)
public String createRefreshToken(Long userId)

// 토큰 파싱 및 검증
public Jws<Claims> parse(String token)
public Long getUserId(String token)
public List<String> getRoles(String token)
public boolean isExpired(String token)
```

#### 서명 및 암호화
- **알고리즘**: HMAC-SHA256 (HS256)
- **비밀키**: Base64 인코딩된 256비트 키
- **키 관리**: 개발환경용 임시키, 운영환경은 환경변수 주입 방식

```yaml
jwt:
  secret: bqRgdYiJ8PphtR0lZhoo8Rzch+TJechjMOyF9+j8pSQ=  # 개발용
  access-validaity-ms: 1800000   # 30분
  refresh-validity-ms: 1209600000 # 14일
```

## Spring Security 설정

### SecurityConfig 구성
```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        return http
            .csrf(csrf -> csrf.disable())              // JWT 사용으로 CSRF 비활성화
            .cors(cors -> cors.disable())              // 개발 환경 CORS 비활성화
            .sessionManagement(sm -> 
                sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))  // 무상태
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/**").permitAll()       // 인증 API 허용
                .requestMatchers("/api/**").permitAll()        // 현재 모든 API 허용
                .requestMatchers("/actuator/**").permitAll()   // 헬스체크 허용  
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()  // API 문서
                .requestMatchers("/admin/**").hasRole("ADMIN") // 관리자 권한
                .anyRequest().authenticated()
            )
            .build();
    }
}
```

### 인증 필터 체인
```
HTTP Request → CORS Filter → JWT Authentication Filter → Security Filter → Controller
```

## JWT 인증 필터 (JwtAuthenticationFilter)

### 필터 동작 순서

#### 1. 화이트리스트 검증
```java
private static final List<String> WHITELIST = List.of(
    "/auth/**",        // 인증 관련 API
    "/actuator/**"     // 헬스체크 API
);
```

#### 2. Authorization 헤더 검증
```http
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### 3. 토큰 파싱 및 사용자 상태 확인
```java
// 토큰에서 사용자 ID 추출
Long userId = Long.valueOf(claims.getSubject());

// 사용자 상태 검증
User user = userRepository.findById(userId).orElse(null);
if (user == null || user.getStatus() != User.Status.ACTIVE || user.isLocked()) {
    // 인증 실패 처리
}
```

#### 4. Spring Security Context 설정
```java
CustomUserPrincipal principal = new CustomUserPrincipal(
    user.getId(), user.getEmail(), user.getPasswordHash(), roles
);
UsernamePasswordAuthenticationToken authToken = 
    new UsernamePasswordAuthenticationToken(principal, null, principal.getAuthorities());
SecurityContextHolder.getContext().setAuthentication(authToken);
```

## 인증 서비스 (AuthService)

### 회원가입 프로세스

#### 1. 이메일 중복 검증
```java
String email = req.getEmail().trim().toLowerCase();
if (userRepository.existsByEmail(email)) {
    throw new IllegalArgumentException("이미 사용 중인 이메일입니다.");
}
```

#### 2. 패스워드 암호화
```java
user.setPasswordHash(passwordEncoder.encode(req.getPassword()));
```

#### 3. 초기 사용자 상태 설정
- **status**: ACTIVE (즉시 활성화)
- **locked**: false
- **failCount**: 0

### 로그인 프로세스

#### 1. 이메일 기반 사용자 조회
```java
User user = userRepository.findByEmail(email)
    .orElseThrow(() -> new IllegalArgumentException("이메일 또는 비밀번호가 올바르지 않습니다."));
```

#### 2. 계정 상태 확인
- 계정 잠금 여부 검증
- 비활성 상태 확인

#### 3. 패스워드 검증 및 실패 카운팅
```java
if (!passwordEncoder.matches(raw, hash)) {
    int failCount = user.getFailCount() + 1;
    user.setFailCount(failCount);
    
    // 5회 실패 시 계정 잠금
    if (failCount >= 5) {
        user.setLocked(true);
        user.setLockedAt(LocalDateTime.now());
    }
    throw new IllegalArgumentException("이메일 또는 비밀번호가 올바르지 않습니다.");
}
```

#### 4. 성공 시 토큰 발급
```java
// 실패 카운트 초기화
user.setFailCount(0);
user.setLastLoginAt(LocalDateTime.now());

// JWT 토큰 생성
String accessToken = jwtTokenProvider.createAccessToken(user.getId(), user.getEmail(), roles);
String refreshToken = jwtTokenProvider.createRefreshToken(user.getId());

// Refresh Token 영속화
RefreshToken rt = RefreshToken.builder()
    .token(refreshToken)
    .user(user)
    .expiresAt(LocalDateTime.now().plusDays(14))
    .revoked(false)
    .build();
refreshTokenRepository.save(rt);
```

### 로그아웃 프로세스
```java
public void logout(LogoutRequest req) {
    refreshTokenRepository.findByToken(req.getRefreshToken())
        .ifPresent(rt -> rt.setRevoked(true));  // 토큰 무효화
}
```

## 보안 관련 엔티티

### RefreshToken
```java
@Entity
public class RefreshToken {
    private Long id;
    private String token;       // 암호화된 refresh token
    private User user;          // 소유자
    private LocalDateTime expiresAt;    // 만료일시
    private boolean revoked;    // 폐기 여부
}
```

### PasswordResetToken (향후 구현)
```java
@Entity  
public class PasswordResetToken {
    private Long id;
    private String token;       // 재설정 토큰
    private User user;          // 대상 사용자
    private LocalDateTime expiresAt;    // 만료일시 (보통 1시간)
    private boolean used;       // 사용 여부
}
```

### VerifyEmailToken (향후 구현)
```java
@Entity
public class VerifyEmailToken {
    private Long id;
    private String token;       // 이메일 인증 토큰
    private User user;          // 대상 사용자
    private LocalDateTime expiresAt;    // 만료일시 (보통 24시간)
    private boolean verified;   // 인증 완료 여부
}
```

## 보안 취약점 대응

### 1. 무차별 대입 공격 (Brute Force)
- **방어 메커니즘**: 로그인 실패 5회 시 계정 자동 잠금
- **잠금 해제**: 관리자 개입 필요 (자동 해제 미구현)
- **추가 고려사항**: IP 기반 레이트 리미팅 (향후 구현)

### 2. JWT 토큰 보안
```java
// 토큰 만료 확인
public boolean isExpired(String token) {
    try {
        Date exp = parse(token).getBody().getExpiration();
        return exp.before(new Date());
    } catch (ExpiredJwtException e) {
        return true;
    }
}
```

### 3. 사용자 입력 검증
```java
// 회원가입 검증
@Email @NotBlank private String email;
@NotBlank @Size(min=8, max=64) private String password;
@NotBlank @Size(min=1, max=30) private String nickname;
```

### 4. SQL Injection 방어
- **JPA Repository**: 파라미터 바인딩으로 자동 방어
- **Native Query**: 사용 시 파라미터 바인딩 강제

### 5. XSS 방어
- **JSON 응답**: HTML 이스케이프 자동 처리
- **템플릿 콘텐츠**: 사용자 입력 시 추가 검증 필요

## 에러 처리 및 응답

### 인증 실패 응답
```json
{
  "success": false,
  "message": "UNAUTHORIZED",
  "data": null
}
```

### 권한 부족 응답
```json
{
  "success": false, 
  "message": "FORBIDDEN",
  "data": null
}
```

### 잘못된 토큰 응답
```json
{
  "success": false,
  "message": "INVALID_TOKEN",
  "data": null
}
```

## 보안 설정 권장사항

### 운영 환경 설정
```yaml
jwt:
  secret: ${JWT_SECRET}                    # 환경변수로 주입
  access-validaity-ms: 900000             # 15분으로 단축
  refresh-validity-ms: 604800000          # 7일로 단축
```

### HTTPS 강제
```yaml
server:
  ssl:
    enabled: true
  port: 443
```

### CORS 정책 설정
```java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    configuration.setAllowedOrigins(List.of("https://trusted-domain.com"));
    configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE"));
    configuration.setAllowedHeaders(List.of("*"));
    configuration.setAllowCredentials(true);
    
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);
    return source;
}
```

### 보안 헤더 추가
```java
http.headers(headers -> headers
    .frameOptions().deny()
    .contentTypeOptions().and()
    .httpStrictTransportSecurity(hstsConfig -> hstsConfig
        .maxAgeInSeconds(31536000)
        .includeSubdomains(true)
    )
);
```

## 모니터링 및 로깅

### 보안 이벤트 로깅
- 로그인 성공/실패
- 계정 잠금 이벤트
- 토큰 검증 실패
- 권한 위반 시도

### 추천 로그 형식
```java
log.warn("Login failed for email: {} from IP: {}, attempt: {}", 
    email, request.getRemoteAddr(), failCount);
    
log.info("Account locked for user: {} due to {} failed attempts", 
    user.getEmail(), MAX_FAILED_ATTEMPTS);
```

이러한 보안 시스템은 현대적인 웹 애플리케이션의 보안 요구사항을 충족하며, 확장성과 유지보수성을 고려하여 설계되었습니다.