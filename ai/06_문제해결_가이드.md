# 06. 문제해결 가이드

## 🚨 일반적인 문제와 해결책

### 1. API 키 관련 문제

#### 문제: "GOOGLE_API_KEY가 설정되지 않았습니다"
```
ValueError: GOOGLE_API_KEY가 .env 파일에 설정되지 않았습니다.
```

**해결책:**
```bash
# 1. .env 파일 존재 확인
ls -la .env

# 2. .env 파일 생성 또는 수정
cat > .env << EOF
GOOGLE_API_KEY=your_actual_api_key_here
GEMINI_API_KEY=your_actual_api_key_here
ENVIRONMENT=development
EOF

# 3. API 키 형식 확인 (AIza로 시작하는 39자)
echo $GOOGLE_API_KEY | wc -c  # 40자여야 함 (마지막 개행 포함)
```

#### 문제: "API 키 권한 거부"
```
403 Forbidden: Your API key doesn't have permission
```

**해결책:**
1. Google Cloud Console에서 Generative AI API 활성화 확인
2. API 키의 제한 사항 확인
3. 새로운 API 키 생성

### 2. 의존성 설치 문제

#### 문제: "Python 버전 호환성 오류"
```
ERROR: Package requires Python >=3.11.13 but you have 3.10.x
```

**해결책:**
```bash
# pyenv 사용하여 정확한 버전 설치
pyenv install 3.11.13
pyenv local 3.11.13
python --version  # Python 3.11.13 확인

# 가상환경 재생성
rm -rf venv
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt
```

#### 문제: "FAISS 설치 오류"
```
ERROR: Failed building wheel for faiss-cpu
```

**해결책:**
```bash
# Windows의 경우
pip install faiss-cpu --no-cache-dir

# Linux/macOS의 경우
sudo apt install build-essential  # Ubuntu
brew install llvm  # macOS

# conda 사용 (권장)
conda install -c conda-forge faiss-cpu
```

### 3. FAISS 인덱스 관련 문제

#### 문제: "FAISS 인덱스 파일 없음"
```
FileNotFoundError: faiss_index_policy.bin not found
```

**해결책:**
```python
# 인덱스 재생성 스크립트
from src.core.index_manager import IndexManager

# 인덱스 매니저 초기화
index_manager = IndexManager()

# 인덱스 재구축
index_manager.rebuild_all_indexes()
print("인덱스 재구축 완료")
```

#### 문제: "인덱스 손상"
```
RuntimeError: Index appears to be corrupted
```

**해결책:**
```bash
# 캐시 디렉토리 정리
rm -rf cache/*

# 애플리케이션 재시작하여 인덱스 재구축
python main.py
```

### 4. 서버 실행 문제

#### 문제: "포트 이미 사용 중"
```
OSError: [Errno 98] Address already in use
```

**해결책:**
```bash
# 포트 사용 중인 프로세스 찾기
netstat -tlnp | grep :8000
# 또는
lsof -i :8000

# 프로세스 종료
kill -9 <PID>

# 다른 포트 사용
uvicorn server:app --port 8001
```

#### 문제: "FastAPI 서버 시작 실패"
```
ImportError: No module named 'fastapi'
```

**해결책:**
```bash
# 가상환경 활성화 확인
which python
which pip

# 의존성 재설치
pip install fastapi uvicorn
# 또는
pip install -r requirements.txt --force-reinstall
```

### 5. AI 생성 관련 문제

#### 문제: "템플릿 생성 실패"
```
Exception: Template generation failed after 3 retries
```

**해결책:**
1. **API 키 확인**:
```bash
# API 키 테스트
curl -H "x-goog-api-key: $GOOGLE_API_KEY" \
     "https://generativelanguage.googleapis.com/v1/models"
```

2. **로그 확인**:
```python
# 디버그 모드로 실행
import logging
logging.basicConfig(level=logging.DEBUG)

# 또는 환경 변수 설정
export PYTHONPATH=.
export LOG_LEVEL=DEBUG
python main.py
```

3. **입력 텍스트 검증**:
```python
# 입력 길이 확인
user_input = "your_input_text"
if len(user_input) > 1000:
    print("입력 텍스트가 너무 깁니다")
    
# 특수 문자 확인
import re
if re.search(r'[^\w\s가-힣]', user_input):
    print("특수 문자가 포함되어 있습니다")
```

#### 문제: "Agent2 병렬 실행 오류"
```
RuntimeError: Parallel execution failed
```

**해결책:**
```python
# src/agents/agent2.py 디버그
def debug_parallel_execution(self, user_input):
    """각 도구별로 순차 실행하여 문제 지점 파악"""
    
    try:
        blacklist_result = self.blacklist_tool.analyze(user_input)
        print("Blacklist OK")
    except Exception as e:
        print(f"Blacklist 오류: {e}")
    
    try:
        whitelist_result = self.whitelist_tool.analyze(user_input)
        print("Whitelist OK")
    except Exception as e:
        print(f"Whitelist 오류: {e}")
    
    # 가이드라인, 법령 도구도 동일하게 테스트
```

### 6. 메모리 관련 문제

#### 문제: "메모리 부족 오류"
```
MemoryError: Unable to allocate array
```

**해결책:**
1. **FAISS 인덱스 최적화**:
```python
# src/core/index_manager.py
def optimize_index_memory(self):
    """메모리 효율적인 인덱스 로딩"""
    
    # 인덱스를 필요할 때만 로드
    if self.policy_index is None:
        self.policy_index = faiss.read_index(self.policy_index_file)
        
    # 사용 후 메모리 해제
    def cleanup_index(self):
        if hasattr(self, 'policy_index'):
            del self.policy_index
            self.policy_index = None
```

2. **배치 크기 조정**:
```python
# 대량 데이터 처리시
def process_in_batches(data, batch_size=100):
    for i in range(0, len(data), batch_size):
        batch = data[i:i+batch_size]
        yield batch
```

### 7. 네트워크 관련 문제

#### 문제: "Gemini API 연결 실패"
```
requests.exceptions.ConnectTimeout: Request timed out
```

**해결책:**
```python
# 타임아웃 및 재시도 설정
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def create_robust_session():
    session = requests.Session()
    
    # 재시도 전략
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504]
    )
    
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    return session
```

### 8. 인코딩 관련 문제

#### 문제: "한글 텍스트 인코딩 오류"
```
UnicodeDecodeError: 'utf-8' codec can't decode byte
```

**해결책:**
```python
# 파일 읽기시 인코딩 명시
def read_korean_file(filepath):
    encodings = ['utf-8', 'cp949', 'euc-kr']
    
    for encoding in encodings:
        try:
            with open(filepath, 'r', encoding=encoding) as f:
                return f.read()
        except UnicodeDecodeError:
            continue
    
    raise ValueError(f"파일 {filepath}의 인코딩을 확인할 수 없습니다")

# 환경 변수로 강제 설정
import os
os.environ['PYTHONIOENCODING'] = 'utf-8'
```

## 🔧 디버깅 도구

### 1. 로그 분석
```python
# 상세 로깅 설정
import logging

def setup_detailed_logging():
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s',
        handlers=[
            logging.FileHandler('debug.log', encoding='utf-8'),
            logging.StreamHandler()
        ]
    )

# 각 모듈별 로거 설정
logger = logging.getLogger(__name__)
logger.debug("디버그 메시지")
logger.info("정보 메시지")  
logger.warning("경고 메시지")
logger.error("오류 메시지")
```

### 2. 성능 프로파일링
```python
import cProfile
import pstats

def profile_function(func, *args, **kwargs):
    """함수 실행 성능 분석"""
    profiler = cProfile.Profile()
    profiler.enable()
    
    result = func(*args, **kwargs)
    
    profiler.disable()
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative')
    stats.print_stats(10)  # 상위 10개 출력
    
    return result

# 사용 예시
result = profile_function(template_generator.generate_template, "쿠폰 발급")
```

### 3. 메모리 사용량 모니터링
```python
import psutil
import tracemalloc

def monitor_memory():
    """메모리 사용량 모니터링"""
    process = psutil.Process()
    memory_info = process.memory_info()
    
    print(f"RSS: {memory_info.rss / 1024 / 1024:.2f} MB")
    print(f"VMS: {memory_info.vms / 1024 / 1024:.2f} MB")

def trace_memory_usage():
    """메모리 누수 추적"""
    tracemalloc.start()
    
    # 코드 실행
    
    current, peak = tracemalloc.get_traced_memory()
    print(f"현재: {current / 1024 / 1024:.2f} MB")
    print(f"최대: {peak / 1024 / 1024:.2f} MB")
    tracemalloc.stop()
```

## 📊 성능 최적화

### 1. 응답 시간 개선
```python
# 캐싱을 통한 성능 개선
from functools import lru_cache
import hashlib

class OptimizedAgent2:
    @lru_cache(maxsize=100)
    def cached_validate(self, input_hash: str):
        """검증 결과 캐싱"""
        return self.parallel_validate(input_hash)
    
    def generate_with_cache(self, user_input: str):
        # 입력 해시 생성
        input_hash = hashlib.md5(user_input.encode()).hexdigest()
        
        # 캐시된 결과 사용
        validation_result = self.cached_validate(input_hash)
        return self.generate_template(validation_result)
```

### 2. 데이터베이스 쿼리 최적화
```python
# FAISS 인덱스 최적화
def optimize_faiss_search(self, query_vector, k=5):
    """효율적인 벡터 검색"""
    
    # GPU 사용 가능시 GPU 인덱스 사용
    if hasattr(faiss, 'StandardGpuResources'):
        try:
            res = faiss.StandardGpuResources()
            gpu_index = faiss.index_cpu_to_gpu(res, 0, self.index)
            distances, indices = gpu_index.search(query_vector, k)
        except:
            # GPU 실패시 CPU 폴백
            distances, indices = self.index.search(query_vector, k)
    else:
        distances, indices = self.index.search(query_vector, k)
    
    return distances, indices
```

## 🆘 긴급 상황 대응

### 1. 서비스 중단시 복구
```bash
#!/bin/bash
# emergency_recovery.sh

echo "=== 긴급 복구 스크립트 ==="

# 1. 서비스 상태 확인
systemctl status jober-ai

# 2. 로그 확인
tail -50 /var/log/jober-ai/error.log

# 3. 서비스 재시작
sudo systemctl restart jober-ai

# 4. 헬스체크
sleep 10
if curl -f http://localhost:8000/health; then
    echo "✅ 서비스 복구 완료"
else
    echo "❌ 서비스 복구 실패 - 관리자에게 연락"
    # 관리자 알림
    curl -X POST https://hooks.slack.com/your-webhook \
         -H 'Content-type: application/json' \
         --data '{"text":"🚨 JOBER AI 서비스 복구 실패"}'
fi
```

### 2. 데이터베이스 백업 복구
```bash
# 백업 생성
tar -czf backup_$(date +%Y%m%d_%H%M%S).tar.gz data/ predata/ cache/

# 백업 복구
tar -xzf backup_20250904_143000.tar.gz
```

### 3. 롤백 절차
```bash
#!/bin/bash
# rollback.sh

BACKUP_VERSION=$1

if [ -z "$BACKUP_VERSION" ]; then
    echo "사용법: ./rollback.sh <version>"
    exit 1
fi

echo "버전 $BACKUP_VERSION으로 롤백 중..."

# 현재 버전 백업
git tag "backup-$(date +%Y%m%d-%H%M%S)"

# 지정 버전으로 롤백
git checkout $BACKUP_VERSION

# 의존성 업데이트
pip install -r requirements.txt

# 서비스 재시작
sudo systemctl restart jober-ai

echo "롤백 완료"
```

## 📞 지원 및 문의

### 1. 로그 수집 스크립트
```bash
#!/bin/bash
# collect_logs.sh

echo "=== 로그 수집 스크립트 ==="

# 시스템 정보
echo "=== 시스템 정보 ===" > debug_info.txt
uname -a >> debug_info.txt
python --version >> debug_info.txt
pip freeze >> debug_info.txt

# 애플리케이션 로그
echo "=== 애플리케이션 로그 ===" >> debug_info.txt
tail -100 debug.log >> debug_info.txt

# 시스템 로그
echo "=== 시스템 로그 ===" >> debug_info.txt  
journalctl -u jober-ai -n 50 >> debug_info.txt

# 압축
tar -czf debug_$(date +%Y%m%d_%H%M%S).tar.gz debug_info.txt debug.log

echo "로그 수집 완료: debug_$(date +%Y%m%d_%H%M%S).tar.gz"
```

### 2. 문제 보고 템플릿
```markdown
## 문제 보고

### 환경 정보
- OS: 
- Python 버전:
- JOBER AI 버전:

### 문제 설명
[문제에 대한 상세한 설명]

### 재현 단계
1. 
2. 
3. 

### 기대 결과
[예상했던 결과]

### 실제 결과
[실제 발생한 결과]

### 오류 메시지
```
[오류 메시지 전문]
```

### 추가 정보
[스크린샷, 로그 파일 등]
```

---

**연락처:**
- 📧 이메일: support@jober.ai  
- 🐛 이슈 트래커: [GitHub Issues](https://github.com/your-username/Jober_ai/issues)
- 📚 문서: [상세 문서](./README.md)

---

**이전 문서**: [05_배포_가이드.md](./05_배포_가이드.md)